Count|Prep|Prep Avg|Query|Query Avg|Get|Get Avg|Total|Total Avg|CMD
4|83748128|20937032|171010238|42752559|865441|216360|255623807|63905951| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)       UNION -- Adding another OR       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
1|12413396|12413396|39232887|39232887|105214|105214|51751497|51751497| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ?) AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           -- Entities that don't have the specified prop           SELECT e.eSID,e.Type,e.Path FROM Entities AS e           WHERE e.RegSID=? AND e.Abstract=? AND             NOT EXISTS (SELECT 1 FROM FullTree WHERE               RegSID=e.RegSID AND eSID=e.eSID AND (BINARY PropName=?))           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
11|41662908|3787537|88572244|8052022|280202|25472|130515354|11865032| 	    SELECT EXISTS(SELECT 1 FROM FullTree 		WHERE RegSID=? AND Type=3 AND 		  Path LIKE 'dirs/d1/%' AND 		  PropName='readonly,' AND 		  PropValue='true')
55|208018841|3782160|1240233245|22549695|3438791|62523|1451690877|26394379| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND Path=? ORDER BY Path
4|51060800|12765200|75632133|18908033|378125|94531|127071058|31767764| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND DocView=true AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
14|174405462|12457533|313630958|22402211|1291287|92234|489327707|34951979| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ?) AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
1|12047124|12047124|27549888|27549888|211386|211386|39808398|39808398| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ?) AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND ((PropType<>'string' AND PropValue=?)  OR (PropType='string' AND PropValue LIKE ?)))           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
3|105375049|35125016|204716458|68238819|535034|178344|310626541|103542180| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           UNION ALL           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)       UNION -- Adding another OR       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           UNION ALL           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
2|7754927|3877463|7649969|3824984|47381|23690|15452277|7726138| 	    SELECT EXISTS(SELECT 1 FROM FullTree 		WHERE RegSID=? AND Type=3 AND 		  Path LIKE 'dirs/d4/%' AND 		  PropName='readonly,' AND 		  PropValue='true')
4|2122679|530669|1377446|344361|73171|18292|3573296|893324|select * from Versions where ResourceSID=?
231|46731439|202300|52611199|227754|2197173|9511|101539811|439566| 	   	SELECT SID 	   	FROM Registries 	   	WHERE UID=?
425|96518207|227101|122196085|287520|4418525|10396|223132817|525018|             SELECT VersionUID, Ancestor, Pos FROM VersionAncestors 			WHERE RegistrySID=? AND ResourceSID=? 			ORDER BY Pos ASC, Time ASC, VersionUID ASC
211|66459430|314973|61046209|289318|2972379|14087|130478018|618379|             SELECT Content FROM ResourceContents WHERE VersionSID=? 
1|12632390|12632390|37864940|37864940|175776|175776|50673106|50673106| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ?) AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           -- Entities that don't have the specified prop           SELECT e.eSID,e.Type,e.Path FROM Entities AS e           WHERE e.RegSID=? AND e.Abstract=? AND             NOT EXISTS (SELECT 1 FROM FullTree WHERE               RegSID=e.RegSID AND eSID=e.eSID AND (BINARY PropName=? AND PropValue=?))           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
2|24255109|12127554|61040146|30520073|351669|175834|85646924|42823462| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ?) AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue IS NOT NULL)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
3|11677599|3892533|65925149|21975049|313540|104513|77916288|25972096| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ? OR Path=? OR Path LIKE ? OR Path=? OR Path LIKE ?)
3|11295019|3765006|11995805|3998601|71190|23730|23362014|7787338| 	    SELECT EXISTS(SELECT 1 FROM FullTree 		WHERE RegSID=? AND Type=3 AND 		  Path LIKE 'dirs/d2/%' AND 		  PropName='readonly,' AND 		  PropValue='true')
419|238142141|568358|266213101|635353|10846800|25887|515202042|1229599| 		SELECT             e.RegSID as RegSID,             e.Type as Type,             e.Plural as Plural,             e.Singular as Singular,             e.eSID as eSID,             e.UID as UID,             p.PropName as PropName,             p.PropValue as PropValue,             p.PropType as PropType,             e.Path as Path,             e.Abstract as Abstract         FROM Entities AS e         LEFT JOIN Props AS p ON (e.eSID=p.EntitySID)         WHERE e.RegSID=? AND (Abstract=? OR Abstract=?)  ORDER BY Path
1278|701937925|549247|829651694|649179|25150496|19679|1556740115|1218106| 		SELECT             e.RegSID as RegSID,             e.Type as Type,             e.Plural as Plural,             e.Singular as Singular,             e.eSID as eSID,             e.UID as UID,             p.PropName as PropName,             p.PropValue as PropValue,             p.PropType as PropType,             e.Path as Path,             e.Abstract as Abstract         FROM Entities AS e         LEFT JOIN Props AS p ON (e.eSID=p.EntitySID)         WHERE e.RegSID=? AND e.Path COLLATE utf8mb4_0900_ai_ci=? ORDER BY Path
423|1598206313|3778265|12762493349|30171379|53357153|126139|14414056815|34075784| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ?)
31|16862963|543966|15195181|490167|857091|27648|32915235|1061781| 		SELECT             e.RegSID as RegSID,             e.Type as Type,             e.Plural as Plural,             e.Singular as Singular,             e.eSID as eSID,             e.UID as UID,             p.PropName as PropName,             p.PropValue as PropValue,             p.PropType as PropType,             e.Path as Path,             e.Abstract as Abstract         FROM Entities AS e         LEFT JOIN Props AS p ON (e.eSID=p.EntitySID)         WHERE e.RegSID=? AND (ParentSID=? AND Type=?)  ORDER BY Path
6|75710112|12618352|216985350|36164225|346499|57749|293041961|48840326| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           -- Entities that don't have the specified prop           SELECT e.eSID,e.Type,e.Path FROM Entities AS e           WHERE e.RegSID=? AND e.Abstract=? AND             NOT EXISTS (SELECT 1 FROM FullTree WHERE               RegSID=e.RegSID AND eSID=e.eSID AND (BINARY PropName=?))           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
14|8220325|587166|8551588|610827|192321|13737|16964234|1211731| 			SELECT UID 			FROM Entities 			WHERE RegSID=? AND Abstract=?
2|38124512|19062256|66786317|33393158|172362|86181|105083191|52541595| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           UNION ALL           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
1|21194246|21194246|59403074|59403074|257557|257557|80854877|80854877| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ?) AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           -- Entities that don't have the specified prop           SELECT e.eSID,e.Type,e.Path FROM Entities AS e           WHERE e.RegSID=? AND e.Abstract=? AND             NOT EXISTS (SELECT 1 FROM FullTree WHERE               RegSID=e.RegSID AND eSID=e.eSID AND (BINARY PropName=? AND PropValue=?))           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)       UNION -- Adding another OR       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue IS NOT NULL)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
1|1126182|1126182|4976124|4976124|39145|39145|6141451|6141451|SELECT e.Path,p.PropName,p.PropValue FROM Props AS p JOIN Entities AS e ON (p.EntitySID=e.eSID) WHERE p.RegistrySID=? ORDER BY Path, PropName 
1480|298891063|201953|419132509|283197|43131168|29142|761154740|514293|         SELECT             SID, RegistrySID, ParentSID, Plural, Singular, Attributes, 			MaxVersions, SetVersionId, SetDefaultSticky, HasDocument, 			TypeMap, Labels, MetaAttributes, ModelVersion, CompatibleWith, 			Description         FROM ModelEntities         WHERE RegistrySID=?         ORDER BY ParentSID ASC
151|555814699|3680892|4621647996|30606940|37839508|250592|5215302203|34538425| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=?
81|305948403|3777140|1804588908|22278875|11184680|138082|2121721991|26194098| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ?) ORDER BY Path
245|51029689|208284|53916534|220067|6595769|26921|111541992|455273|         SELECT PropName, PropValue, PropType         FROM Props WHERE EntitySID=? 
3128|1904879721|608976|2120927259|678045|91184780|29151|4116991760|1316173| 		SELECT             e.RegSID as RegSID,             e.Type as Type,             e.Plural as Plural,             e.Singular as Singular,             e.eSID as eSID,             e.UID as UID,             p.PropName as PropName,             p.PropValue as PropValue,             p.PropType as PropType,             e.Path as Path,             e.Abstract as Abstract         FROM Entities AS e         LEFT JOIN Props AS p ON (e.eSID=p.EntitySID)         WHERE e.RegSID=? AND e.Path=? ORDER BY Path
20|254928985|12746449|568757159|28437857|3911719|195585|827597863|41379893| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
15|192526054|12835070|388422300|25894820|5239236|349282|586187590|39079172| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue IS NOT NULL)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
20|245447450|12272372|517414039|25870701|5822410|291120|768683899|38434194| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND ((PropType<>'string' AND PropValue=?)  OR (PropType='string' AND PropValue LIKE ?)))           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
1|19264431|19264431|49729966|49729966|124773|124773|69119170|69119170| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           -- Entities that don't have the specified prop           SELECT e.eSID,e.Type,e.Path FROM Entities AS e           WHERE e.RegSID=? AND e.Abstract=? AND             NOT EXISTS (SELECT 1 FROM FullTree WHERE               RegSID=e.RegSID AND eSID=e.eSID AND (BINARY PropName=? AND PropValue=?))           UNION ALL           SELECT eSID,Type,Path FROM FullTree WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue IS NOT NULL)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
1|20850065|20850065|59111965|59111965|332860|332860|80294890|80294890| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           -- Entities that don't have the specified prop           SELECT e.eSID,e.Type,e.Path FROM Entities AS e           WHERE e.RegSID=? AND e.Abstract=? AND             NOT EXISTS (SELECT 1 FROM FullTree WHERE               RegSID=e.RegSID AND eSID=e.eSID AND (BINARY PropName=? AND PropValue=?))           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)       UNION -- Adding another OR       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue IS NOT NULL)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
1|19129084|19129084|48995338|48995338|911736|911736|69036158|69036158| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ?) AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           -- Entities that don't have the specified prop           SELECT e.eSID,e.Type,e.Path FROM Entities AS e           WHERE e.RegSID=? AND e.Abstract=? AND             NOT EXISTS (SELECT 1 FROM FullTree WHERE               RegSID=e.RegSID AND eSID=e.eSID AND (BINARY PropName=? AND PropValue=?))           UNION ALL           SELECT eSID,Type,Path FROM FullTree WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue IS NOT NULL)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
2|7502468|3751234|7414834|3707417|35332|17666|14952634|7476317| 	    SELECT EXISTS(SELECT 1 FROM FullTree 		WHERE RegSID=? AND Type=3 AND 		  Path LIKE 'dirs/d3/%' AND 		  PropName='readonly,' AND 		  PropValue='true')
1480|306353378|206995|357979902|241878|19238217|12998|683571497|461872|SELECT Labels, Attributes FROM Models WHERE RegistrySID=?
20|78583595|3929179|115905241|5795262|2746380|137319|197235216|9861760| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND DocView=true
2|39335933|19667966|61629909|30814954|177995|88997|101143837|50571918| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND DocView=true AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           UNION ALL           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
2|8455048|4227524|44639192|22319596|475818|237909|53570058|26785029| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ? OR Path=? OR Path LIKE ? OR Path=? OR Path LIKE ? OR Path=? OR Path LIKE ?)
15|56707214|3780480|414857496|27657166|2087737|139182|473652447|31576829| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND (Path=? OR Path LIKE ? OR Path=? OR Path LIKE ?)
90|65349794|726108|315924039|3510267|1490418|16560|382764251|4252936| 			SELECT v.UID,p.PropValue FROM Versions AS v 			JOIN EffectiveProps as p 			  ON (p.EntitySID=v.SID AND 			      p.PropName='createdat,') 			WHERE v.RegistrySID=? AND v.ResourceSID=? 			  ORDER BY p.PropValue ASC, v.UID ASC
1|3726062|3726062|3819124|3819124|22487|22487|7567673|7567673| 	    SELECT EXISTS(SELECT 1 FROM FullTree 		WHERE RegSID=? AND Type=3 AND 		  Path LIKE 'dirs/d5/%' AND 		  PropName='readonly,' AND 		  PropValue='true')
1|3808041|3808041|7663862|7663862|24383|24383|11496286|11496286| 	    SELECT EXISTS(SELECT 1 FROM FullTree 		WHERE RegSID=? AND Type=3 AND 		  Path LIKE 'dirs/dir1/%' AND 		  PropName='readonly,' AND 		  PropValue='true')
42|167735384|3993699|297140958|7074784|3295580|78466|468171922|11146950| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND DocView=true AND (Path=? OR Path LIKE ?)
3|40014990|13338330|61172391|20390797|307351|102450|101494732|33831577| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND DocView=true AND (Path=? OR Path LIKE ?) AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           SELECT eSID,Type,Path FROM FullTree             WHERE RegSID=? AND (BINARY Abstract=? AND PropName=? AND PropValue=?)           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
3|38386804|12795601|116823527|38941175|334447|111482|155544778|51848259| SELECT   RegSID,Type,Plural,Singular,eSID,UID,PropName,PropValue,PropType,Path,Abstract FROM FullTree WHERE RegSID=? AND ( eSID IN ( -- eSID from query   -- Find all entities that match the filters, and then grab all parents   -- This "RECURSIVE" stuff finds all parents   WITH RECURSIVE cte(eSID,Type,ParentSID,Path) AS (     -- This defines the init set of rows of the query. We'll recurse later on     SELECT eSID,Type,ParentSID,Path FROM Entities     WHERE eSID in ( -- start of the OR Filter groupings       -- start of one Filter AND grouping (expr1 AND expr2).       -- Find all SIDs for the leaves for entities (SIDs) of interest.       SELECT list.eSID FROM (         SELECT count(*) as cnt,e2.eSID,e2.Path FROM Entities AS e1         RIGHT JOIN (           -- start of expr1 - below finds SearchNodes/SIDs of interest           -- Entities that don't have the specified prop           SELECT e.eSID,e.Type,e.Path FROM Entities AS e           WHERE e.RegSID=? AND e.Abstract=? AND             NOT EXISTS (SELECT 1 FROM FullTree WHERE               RegSID=e.RegSID AND eSID=e.eSID AND (BINARY PropName=? AND PropValue=?))           -- end of expr1         ) AS result ON ( result.eSID=e1.eSID )         -- For each result found, find all Leaves under the matching entity.         -- The Leaves that show up 'cnt' times, where cnt is the # of         -- expressions in each filter (the ANDs), are branches to return.         -- Note we return the Path of each Leaf, not the path of the matching         -- entity. The entity that matches isn't important.         JOIN Entities AS e2 ON (           (             (               -- Non-meta objects, just compare the Path               result.Type<>3 AND               ( e2.Path=result.Path OR                 e2.Path LIKE CONCAT(IF(result.Path<>'',CONCAT(result.Path,'/'),''),'%')               )             )             OR             (               -- For 'meta' objects, compare it's parent's Path               result.Type=3 AND               ( e2.Path=TRIM(TRAILING '/meta' FROM result.Path) OR                 e2.Path LIKE CONCAT(TRIM(TRAILING 'meta' FROM result.Path),'%')               )             )           )           AND e2.eSID IN (SELECT * from Leaves)         ) GROUP BY e2.eSID         -- end of RIGHT JOIN       ) as list       WHERE list.cnt=?   -- cnt is the # of operands in the AND filter       -- end of one Filter AND grouping (expr1 AND expr2 ...)     ) -- end of all OR Filter groupings      -- This is the recusive part of the query.     -- Find all of the parents (and 'meta' sub-objects) of the found     -- entities, up to root of Reg.     UNION DISTINCT SELECT       e.eSID,e.Type,e.ParentSID,e.Path     FROM Entities AS e     INNER JOIN cte ON       (         -- Find its parent         e.eSID=cte.ParentSID         OR         -- If this is a Resource, grab its 'meta' sub-object         ( cte.Type=2 AND           e.Type=3 AND           e.ParentSID=cte.eSID         )       )   )   SELECT DISTINCT eSID FROM cte ) ) ORDER BY Path ; 
