package main

import (
	"fmt"
	"io"
	"reflect"
	"runtime"
	"strings"
	"time"
)

var PASS = 0x01
var FAIL = 0x02
var WARN = 0x04
var SKIP = 0x08
var FailFast = true
var TestsRun = map[string]*TD{}

type TestFn func(td *TD)

func (fn TestFn) Name() string {
	name := runtime.FuncForPC(reflect.ValueOf(fn).Pointer()).Name()
	before, name, _ := strings.Cut(name, ".")
	if name == "" {
		name = before
	}
	return name
}

type LogEntry struct {
	Date    time.Time
	Type    int // pass, fail, warning, skip, else log or TD
	Text    string
	Subtest *TD
}

func (le *LogEntry) MarshalText() ([]byte, error) {
	str := le.Date.Format(time.RFC3339)
	if le.Type&PASS != 0 {
		str += " (P): " + le.Text
	} else if le.Type&FAIL != 0 {
		str += " (F): " + le.Text
	} else if le.Type&WARN != 0 {
		str += " (W): " + le.Text
	} else if le.Type&SKIP != 0 {
		str += " (S): " + le.Text
	} else if le.Subtest == nil { // log
		str += "    : " + le.Text
	} else {
		str += " >>>> " + le.Subtest.TestName
	}

	return []byte(str), nil
}

// TestData
type TD struct {
	TestName string
	Parent   *TD `json:"-"`
	Logs     []*LogEntry

	Status int // PASS, FAIL, ...
	Props  map[string]any

	NumPass int // These will include the status of THIS TD and children
	NumFail int
	NumWarn int
	NumSkip int
}

func (td *TD) Dump(indent string) {
	fmt.Printf("%sTestName: %s\n", indent, td.TestName)
	if len(td.Logs) > 0 {
		fmt.Printf("%s  Logs:\n", indent)
		for _, le := range td.Logs {
			if le.Subtest != nil {
				fmt.Printf("%s    %s", indent, le.Date.Format(time.RFC3339))
				le.Subtest.Dump(indent + "    ")
			} else {
				fmt.Printf("%s    %s %q\n", indent, le.Date.Format(time.RFC3339),
					le.Text)
			}
		}
	}
}

func (td *TD) oldWrite(out io.Writer, indent string, showLogs bool) {
	str := indent

	if td.Status&PASS != 0 {
		str += "PASS: "
	} else if td.Status&FAIL != 0 {
		str += "FAIL: "
		/*
			} else if td.Status&WARN != 0 {
				str += "WARN: "
		*/
	} else if td.Status&SKIP != 0 {
		str += "SKIP: "
	} else {
		panic(fmt.Sprintf("Unknown status: %v", td.Status))
	}
	str += td.TestName + "\n"
	out.Write([]byte(str))

	// indent += "| "

	saveIndent := indent

	indent = strings.ReplaceAll(indent, "├─", "│ ")
	indent += "├─ "

	/*
		if len(td.Logs) == 0 {
			indent = strings.ReplaceAll(indent, "└─", "  ")
		} else {
			indent = strings.ReplaceAll(indent, "└─", "│ ")
		}
		indent += "└─ "
	*/
	for i, le := range td.Logs {
		// date := le.Date.Format(time.RFC3339)
		if i+1 == len(td.Logs) {
			indent = saveIndent + "└─ "
		} else {
			indent = saveIndent + "├─ "
		}

		if le.Type&PASS != 0 {
			str = PrettyPrint(indent, "PASS: ", le.Text) + "\n"
		} else if le.Type&FAIL != 0 {
			str = PrettyPrint(indent, "FAIL: ", le.Text) + "\n"
		} else if le.Type&FAIL != 0 {
			str = PrettyPrint(indent, "WARN: ", le.Text) + "\n"
		} else if le.Type&SKIP != 0 {
			str = PrettyPrint(indent, "SKIP: ", le.Text) + "\n"
		} else if le.Subtest == nil { // log
			if showLogs {
				str = PrettyPrint(indent, "", le.Text) + "\n"
			}
		} else { // subtest
			le.Subtest.write(out, indent, showLogs)
			str = ""
		}
		out.Write([]byte(str))
	}
}

type TDWriter struct {
	writer   io.Writer
	passed   int
	failed   int
	warnings int
	skipped  int
}

func (tdw *TDWriter) Write(buf []byte) (int, error) {
	return tdw.writer.Write(buf)
}

func (td *TD) Print(out io.Writer, indent string, showLogs bool) {
	tdw := &TDWriter{
		writer: out,
	}
	td.write(tdw, indent, showLogs)
	out.Write([]byte(fmt.Sprintf("\nPASS: %d  FAIL: %d  WARN: %d  SKIP: %d\n",
		tdw.passed, tdw.failed, tdw.warnings, tdw.skipped)))
	summary := ""
	if tdw.failed == 0 {
		summary += "Passed"
		if tdw.warnings != 0 {
			summary += ", with warnings"
		}
	} else {
		summary += "Failed"
	}
	out.Write([]byte(summary + "\n"))

	fmt.Printf("%d %d %d %d\n", td.NumPass, td.NumFail, td.NumWarn, td.NumSkip)
}

func (td *TD) write(out io.Writer, indent string, showLogs bool) {
	td.writeHeader(out, indent, showLogs)
	td.writeBody(out, indent, showLogs)
}

func (td *TD) writeHeader(out io.Writer, indent string, showLogs bool) {
	str := indent

	if td.Status&PASS != 0 {
		str += "PASS: "
	} else if td.Status&FAIL != 0 {
		str += "FAIL: "
		// } else if td.Status&WARN != 0 {
		// str += "WARN: "
	} else if td.Status&SKIP != 0 {
		str += "SKIP: "
	} else {
		// Just a log msg, no prefix
	}
	out.Write([]byte(str + td.TestName + "\n"))
}

func (td *TD) writeBody(out io.Writer, indent string, showLogs bool) {
	stat, _ := out.(*TDWriter)
	saveIndent := indent
	endSaveIndent := strings.ReplaceAll(saveIndent, "├─", "│ ")

	for i, le := range td.Logs {
		str := ""
		// date := le.Date.Format(time.RFC3339)
		if i+1 == len(td.Logs) {
			indent = endSaveIndent + "└─ "
		} else {
			indent = endSaveIndent + "├─ "
		}

		if le.Type&PASS != 0 {
			str = PrettyPrint(indent, "PASS: ", le.Text) + "\n"
			stat.passed++
		} else if le.Type&FAIL != 0 {
			str = PrettyPrint(indent, "FAIL: ", le.Text) + "\n"
			stat.failed++
		} else if le.Type&WARN != 0 {
			str = PrettyPrint(indent, "WARN: ", le.Text) + "\n"
			stat.warnings++
		} else if le.Type&SKIP != 0 {
			str = PrettyPrint(indent, "SKIP: ", le.Text) + "\n"
			stat.skipped++
		} else if le.Subtest == nil { // log
			if td.Status&PASS == 0 || showLogs {
				str = PrettyPrint(indent, "", le.Text) + "\n"
			}
		} else { // subtest
			if i+1 == len(td.Logs) {
				le.Subtest.writeHeader(out, endSaveIndent+"└─ ", showLogs)
				le.Subtest.writeBody(out, saveIndent+"   ", showLogs)
			} else {
				le.Subtest.write(out, indent, showLogs)
			}
		}
		out.Write([]byte(str))
	}
}

func NewTD(name string) *TD {
	return &TD{
		TestName: name,
		Parent:   nil,
		Logs:     []*LogEntry{},

		Status: PASS,
		Props:  map[string]any{},
	}
}

// PASS|FAIL|WARN|SKIP, testNameText, substitute args for testName
func (td *TD) Report(status int, name string, args ...any) {
	td.Logs = append(td.Logs, &LogEntry{
		Date: time.Now(),
		Type: status,
		Text: fmt.Sprintf(name, args...),
		Subtest: nil,
	})

	if (status & (PASS | FAIL)) == (PASS | FAIL) {
		panic("Bad status - can't be both PASS and FAIL")
	}

	if status & FAIL != 0 {
		td.Status |= FAIL  // set FAIL bit
		td.Status &= ^PASS  // remove any PASS bit
	} else {
		// Treat any non-failure as success
		if td.Status & FAIL == 0 {
			td.Status |= PASS
		}
	}
		td.Status |= (status & (WARN|SKIP)) // Merge any WARN or SKIP bits
}

func (td *TD) Pass(strs ...any) {
	td.Status |= PASS
	if len(strs) > 0 {
		td.Logs = append(td.Logs, &LogEntry{
			Date:    time.Now(),
			Type:    PASS,
			Text:    fmt.Sprintf(strs[0].(string), strs[1:]...),
			Subtest: nil,
		})
	}
	td.NumPass++
}

func (td *TD) Fail(format string, args ...any) {
	td.Logs = append(td.Logs, &LogEntry{
		Date:    time.Now(),
		Type:    FAIL,
		Text:    fmt.Sprintf(format, args...),
		Subtest: nil,
	})
	td.Status |= FAIL
	td.NumFail++
	panic("failed")
}

func (td *TD) Warning(format string, args ...any) {
	td.Logs = append(td.Logs, &LogEntry{
		Date:    time.Now(),
		Type:    WARN,
		Text:    fmt.Sprintf(format, args...),
		Subtest: nil,
	})
	td.Status |= WARN
	td.NumWarn++
}

func (td *TD) Skip(format string, args ...any) {
	td.Logs = append(td.Logs, &LogEntry{
		Date:    time.Now(),
		Type:    SKIP,
		Text:    fmt.Sprintf(format, args...),
		Subtest: nil,
	})
	td.Status |= SKIP
	td.NumSkip++
}

func (td *TD) DependsOn(fn TestFn) {
	if prevTD, ok := TestsRun[fn.Name()]; ok {
		if prevTD.Status&FAIL != 0 {
			td.Log("%s (cached)", fn.Name())
		} else {
			td.Log("%s (cached)", fn.Name())
		}
		return
	}

	newTD := td.Run(fn)

	if newTD.Status&FAIL != 0 {
		td.Fail("Dependency %q failed, exiting", fn.Name())
		return
	} else {
		// td.Log("Dependency %q passed", fn.Name())
	}

	// If we have a TD parent then use "panic" to exit from current
	// function and bubble up to the parent TD
	if td.Status&FAIL != 0 && td.Parent != nil {
		panic("failed")
	}
}

func (td *TD) Run(fn TestFn) *TD {
	before, name, _ := strings.Cut(fn.Name(), ".")
	if name == "" {
		name = before
	}
	newTD := NewTD(name)
	newTD.Parent = td

	newLE := &LogEntry{
		Date:    time.Now(),
		Type:    0,
		Text:    "",
		Subtest: newTD,
	}

	td.Logs = append(td.Logs, newLE)

	TestsRun[fn.Name()] = newTD

	func() {
		defer func() {
			if r := recover(); r != nil {
				// Do nothing
				// Just allow the panic() caller to exit immediately
			}
		}()
		fn(newTD)
	}()

	if newTD.Status&FAIL != 0 {
		td.Status = FAIL
	}
	td.Status |= (newTD.Status & WARN)

	// if td.Status&FAIL != 0 && td.Parent != nil {
	// panic("failed")
	// }

	td.NumPass += newTD.NumPass
	td.NumFail += newTD.NumFail
	td.NumWarn += newTD.NumWarn
	td.NumSkip += newTD.NumSkip

	// If they didn't say THIS TD failed, then assume it passed
	if td.Status & FAIL == 0 {
		td.NumPass++
		td.
	}

	return newTD
}

func (td *TD) Log(format string, args ...any) {
	text := fmt.Sprintf(format, args...)
	td.Logs = append(td.Logs, &LogEntry{
		Date:    time.Now(),
		Type:    0,
		Text:    text,
		Subtest: nil,
	})
}

func PrettyPrint(indent string, prefix string, text string) string {
	width := 79
	line := strings.TrimRight(indent+prefix+text, " ")

	indent = indent + strings.Repeat(" ", len(prefix))

	str := ""

	for len(line) > width {
		left := ""
		chopAt := width // do not use width-1
		for i := chopAt; i+1 > len(indent); i-- {
			runeIt := ([]rune)(line)
			if runeIt[i] == ' ' {
				left = string(runeIt[:i])
				line = strings.TrimLeft(string(runeIt[i+1:]), " ")
				break
			}
		}

		if strings.Contains(indent, "└") {
			indent = strings.ReplaceAll(indent, "└─", "  ")
		} else {
			indent = strings.ReplaceAll(indent, "├─", "│ ")
		}

		line = indent + line
		str += left + "\n"
	}
	str += line
	return str
}
